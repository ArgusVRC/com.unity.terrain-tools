//inputs
Texture2D<float>   InHeightMap;
Texture2D<float>   InSediment;
Texture2D<float2>  WindVel;

float4 texDim;	     // the dimensions of all of our textures (they must all be the same dimensions)
float4 terrainScale; // the dimensions in world space of the terrain tile
float4 dxdy;         // (dx, dy, 1 / dx, 1/ dy), where dx, dy = texel width, height

float dt;
float SuspensionRate;
float DepositionRate;
float SlopeFactor;
float DragCoefficient;
float ReflectionCoefficient;
float AbrasivenessCoefficient;


//outputs
RWTexture2D<float>   OutSediment;
RWTexture2D<float>   OutHeightMap;
RWTexture2D<float2>  OutWindVel;

uint4 getSafeNeighbors(uint2 coord) {
	return uint4(
		(coord.x < (uint)(texDim[0] - 1)) ? coord.x + 1 : coord.x,  //right index
		(coord.x > 0) ? (uint)(coord.x - 1) : coord.x,              //left index
		(coord.y < (uint)(texDim[1] - 1)) ? coord.y + 1 : coord.y,  //bottom index
		(coord.y > 0) ? (uint)(coord.y - 1) : coord.y               //top index
		);
}

#define RIGHT(c)	(c.x)
#define LEFT(c)		(c.y)
#define BOTTOM(c)	(c.z)
#define TOP(c)		(c.w)

float2 computeNormal(uint2 coord) {
	uint4 nidx = getSafeNeighbors(coord);

	float dzdx = ((InHeightMap[uint2(RIGHT(nidx), BOTTOM(nidx))] + 2 * InHeightMap[uint2(RIGHT(nidx), coord.y)] + InHeightMap[uint2(RIGHT(nidx), TOP(nidx))]) -
		(InHeightMap[uint2(LEFT(nidx), BOTTOM(nidx))] + 2 * InHeightMap[uint2(LEFT(nidx), coord.y)] + InHeightMap[uint2(LEFT(nidx), TOP(nidx))])) / 8.0f;

	float dzdy = ((InHeightMap[uint2(LEFT(nidx), TOP(nidx))] + 2 * InHeightMap[uint2(coord.x, TOP(nidx))] + InHeightMap[uint2(RIGHT(nidx), TOP(nidx))]) -
		(InHeightMap[uint2(LEFT(nidx), BOTTOM(nidx))] + 2 * InHeightMap[uint2(coord.x, BOTTOM(nidx))] + InHeightMap[uint2(RIGHT(nidx), BOTTOM(nidx))])) / 8.0f;

	return normalize(float2(terrainScale.y * dzdx * dxdy.z, terrainScale.y * dzdy * dxdy.w));
}

#pragma kernel WindSedimentErode
[numthreads(1,1,1)]
void WindSedimentErode(uint3 id : SV_DispatchThreadID)
{
	float2 n = computeNormal(id.xy);

	float n_dot_w = max(-1.0f * dot(n, WindVel[id.xy] * dxdy.zw), 0.0f);

	float pnw = pow(n_dot_w, SlopeFactor);
	float sandBlast = AbrasivenessCoefficient * dt * InSediment[id.xy];
	float windSwept = SuspensionRate * dt;

	float suspendedSediment = min(pnw * (sandBlast + windSwept), InHeightMap[id.xy]);
	float depositedSediment = min(DepositionRate * dt, InSediment[id.xy]);

	float halfHeight = InHeightMap[id.xy] / 2.0f;
	float dS = clamp(depositedSediment - suspendedSediment, -halfHeight, halfHeight);

	OutSediment[id.xy] = max(InSediment[id.xy] - dS, 0.0f);
	OutHeightMap[id.xy] = max(InHeightMap[id.xy] + dS, 0.0f);
}

#pragma kernel ApplyHeightfieldDrag
[numthreads(1, 1, 1)]
void ApplyHeightfieldDrag(uint3 id : SV_DispatchThreadID)
{
	float2 n = computeNormal(id.xy);

	float2 scaledVel = normalize(WindVel[id.xy]);//WindVel[id.xy] * dxdy.zw;

	//use the reflection vector between wind velocity and surface normal to drive "drag"
	float2 r = scaledVel - 2.0f * (dot(scaledVel, n)) * n;

	float effectiveReflection = ReflectionCoefficient * dt;
	float effectiveDrag = DragCoefficient * dt;

	OutWindVel[id.xy] = WindVel[id.xy] + effectiveReflection * r - effectiveDrag * WindVel[id.xy];
}